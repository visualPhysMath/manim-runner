from __future__ import annotations
from manim import *
import numpy as np

class PendulumTwoCycle(Scene):
    def construct(self):
        # ---- physics ----
        g, l = 9.8, 3.0
        m1, m2 = 2.0, 1.0
        omega0 = np.sqrt(g / l)
        T = 2 * np.pi / omega0
        u = 1.0
        omega1, omega2 = u / l, 0.0
        theta1 = theta2 = 0.0

        def collide(om1, om2):
            v1, v2 = om1, om2
            v1p = ((m1 - m2) / (m1 + m2)) * v1 + (2 * m2 / (m1 + m2)) * v2
            v2p = (2 * m1 / (m1 + m2)) * v1 + ((m2 - m1) / (m1 + m2)) * v2
            return v1p, v2p

        # t=0 で衝突をまず適用
        omega1, omega2 = collide(omega1, omega2)

        # ---- scene ----
        self.camera.background_color = "#0e1117"
        pivot = ORIGIN + UP * 2.5
        scale = 1.0

        def angle_to_point(theta):
            return pivot + l * scale * (np.sin(theta) * RIGHT - np.cos(theta) * DOWN)

        rod1 = Line(pivot, angle_to_point(theta1), stroke_width=4, color=BLUE_E)
        rod2 = Line(pivot, angle_to_point(theta2), stroke_width=4, color=GREEN_E)
        r1, r2 = 0.14 * np.sqrt(m1), 0.14 * np.sqrt(m2)
        bob1 = Circle(radius=r1, color=BLUE_E, fill_opacity=1).set_fill(BLUE_E)
        bob2 = Circle(radius=r2, color=GREEN_E, fill_opacity=1).set_fill(GREEN_E)
        bob1.move_to(rod1.get_end())
        bob2.move_to(rod2.get_end())

        label = VGroup(
            Text("m1 = 2m", color=BLUE_E).scale(0.5),
            Text("m2 = m", color=GREEN_E).scale(0.5),
        ).arrange(DOWN, aligned_edge=LEFT).to_corner(UL).shift(DOWN*0.2+RIGHT*0.2)

        # kinetic energy bars (no TeX)
        bar_base = Axes(
            x_range=[0, 3, 1],
            y_range=[0, 1.0, 0.25],
            x_length=2.6, y_length=2.2,
            axis_config={"include_numbers": False, "stroke_color": GRAY_D, "stroke_opacity": 0.6},
        ).to_corner(UR).shift(LEFT*0.3+DOWN*0.2)
        bar_title = Text("Kinetic energy share", color=GRAY_B).scale(0.35).next_to(bar_base, UP, buff=0.2)

        bar1 = Rectangle(width=0.6, height=0.001, color=BLUE_E, fill_opacity=0.9).set_fill(BLUE_E)
        bar2 = Rectangle(width=0.6, height=0.001, color=GREEN_E, fill_opacity=0.9).set_fill(GREEN_E)
        x1 = bar_base.c2p(0.8, 0); x2 = bar_base.c2p(2.0, 0)
        bar1.move_to(x1, aligned_edge=DOWN); bar2.move_to(x2, aligned_edge=DOWN)
        bar1_label = Text("K1", color=BLUE_E).scale(0.35).next_to(bar1, DOWN, buff=0.08)
        bar2_label = Text("K2", color=GREEN_E).scale(0.35).next_to(bar2, DOWN, buff=0.08)

        hit_glow = Dot(pivot + l*scale*DOWN, radius=0.12, color=YELLOW).set_opacity(0)

        self.add(rod1, rod2, bob1, bob2, label, bar_base, bar_title, bar1, bar2, bar1_label, bar2_label, hit_glow)

        # ---- evolve ----
        eps = 2e-2
        internal_dt = 1/240.0
        speed = 1.0
        state = {"theta1": theta1, "theta2": theta2, "omega1": omega1, "omega2": omega2,
                 "t": 0.0, "cool": 0.0}

        def update_bars():
            K1 = 0.5 * m1 * (l**2) * (state["omega1"]**2)
            K2 = 0.5 * m2 * (l**2) * (state["omega2"]**2)
            total = K1 + K2
            h1 = 0.0 if total < 1e-12 else np.clip(K1/total, 0, 1)
            h2 = 0.0 if total < 1e-12 else np.clip(K2/total, 0, 1)
            bar1.set_height(h1 * bar_base.y_length); bar2.set_height(h2 * bar_base.y_length)
            bar1.move_to(x1, aligned_edge=DOWN); bar2.move_to(x2, aligned_edge=DOWN)

        def place():
            p1 = angle_to_point(state["theta1"]); p2 = angle_to_point(state["theta2"])
            rod1.put_start_and_end_on(pivot, p1); rod2.put_start_and_end_on(pivot, p2)
            bob1.move_to(p1); bob2.move_to(p2)

        def flash_hit():
            hit_glow.move_to(angle_to_point(0.0))
            hit_glow.set_opacity(1.0)
            self.play(FadeOut(hit_glow, run_time=0.15, rate_func=linear))

        update_bars(); place()

        def evolve(mob, dt):
            steps = max(1, int(np.ceil((dt*speed)/internal_dt)))
            h = (dt*speed)/steps
            for _ in range(steps):
                state["omega1"] += -(g/l)*state["theta1"]*h
                state["omega2"] += -(g/l)*state["theta2"]*h
                prev1, prev2 = state["theta1"], state["theta2"]
                state["theta1"] += state["omega1"]*h
                state["theta2"] += state["omega2"]*h
                if state["cool"] > 0: state["cool"] -= h
                near0 = (abs(state["theta1"])<eps) and (abs(state["theta2"])<eps)
                crossing = (prev1*state["theta1"]<=0) and (prev2*state["theta2"]<=0)
                if near0 and crossing and state["cool"]<=0:
                    state["omega1"], state["omega2"] = collide(state["omega1"], state["omega2"])
                    state["cool"] = 0.08
                    flash_hit()
            place(); update_bars()

        d = VMobject(); d.add_updater(evolve); self.add(d)
        caption = VGroup(
            Text("Small-angle; elastic collisions", color=GRAY_B).scale(0.4),
            Text("Energy shares flip {1/9, 8/9} every hit", color=GRAY_B).scale(0.4),
        ).arrange(DOWN, aligned_edge=LEFT).to_corner(DL).shift(UP*0.2+RIGHT*0.2)
        self.add(caption)

        self.wait(4 * T / 2)
        d.remove_updater(evolve)